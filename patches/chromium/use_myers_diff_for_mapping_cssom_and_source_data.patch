From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Erg=C3=BCn=20Erdo=C4=9Fmu=C5=9F?= <ergunsh@chromium.org>
Date: Wed, 11 Jan 2023 11:08:31 +0000
Subject: Use Myers Diff for mapping CSSOM and Source Data
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We need to do mapping between CSSOM (stylesheet's representation
in the renderer) and source data (actual text representation). For that,
we're finding LCS of these two representations and create a mapping from
there. For creating the mapping, the algorithm we were using had
N^2[1] space complexity which caused OOMs in some websites (See the bug).

This change updates the LCS finding algorithm to use Myers Diff
(props to @szuend and thanks to @pfaffe for suggestion) which improves time complexity and linearizes the space complexity needed for the diffing process to get rid of OOM crashes.

In addition to that, I've split css-matching-rules tests because
the behavior we have for internal and external stylesheets are different.
For internal & constructed stylesheets, the source text always contains
the changed CSSOM rules.

FAQ
_Questions I've asked over and over again while investigating this OOM_

**Why do we need mapping between CSSOM and source text since we can expect them to represent the same structure?**
Answer: Stylesheets can be changed programmatically via CSSOM API and
these changes are not reflected in the source code (See crbug.com/178410).

**Why do we need source text at all?**
Answer: For editing stylesheets via Styles pane we mark a CSS
rule's location in the source and update it in the source text when it is
changed. In addition to that, it powers jump to source from Styles pane
for a rule.

**How does editing constructed stylesheets work?**
See the blog post[2]. TL;DR:
* For constructed stylesheets, we create a virtual source text
* For libraries that add `<style>` tags, for creating the source text
of such stylesheet, we're merging the CSSOM changes with source text.
(Thus CSSOM changes always exist in source text)

**Why don't we do merging for all kinds of stylesheets?**
This would make us get rid of diffing if we keep CSSOM changes and
source text in sync. I... don't know... The reason I didn't do in this
CL was it was changing the behavior: We were not able to update CSSOM
changed external stylesheets via Styles pane but after that change, we
could have updated them -- which seems good to me. Though merging
we currently implemented doesn't preserve formatting, thus we were losing jump to source functionality from Styles pane.

Next steps:
Digging through this, I've found out a few improvements
we can make in this regard to make Sediting in Styles pane more reliable
and consistent. So, I'll propose some suggestions later.

[1]: Number of rules in a stylesheet
[2]: https://developer.chrome.com/blog/css-in-js

Fixed: 1268217
Change-Id: I41742b52871af6b5fc29132efb9379e04c74a762
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/4128932
Reviewed-by: Simon Zünd <szuend@chromium.org>
Reviewed-by: Alex Rudenko <alexrudenko@chromium.org>
Reviewed-by: Changhao Han <changhaohan@chromium.org>
Commit-Queue: Ergün Erdoğmuş <ergunsh@chromium.org>
Cr-Commit-Position: refs/heads/main@{#1091256}

diff --git a/third_party/blink/renderer/core/inspector/build.gni b/third_party/blink/renderer/core/inspector/build.gni
index a4b54c52347c6d4467ee533d100e9e8533a4fa7e..bc83401f4152c9f7228a6d7ec53de9e0d614dc56 100644
--- a/third_party/blink/renderer/core/inspector/build.gni
+++ b/third_party/blink/renderer/core/inspector/build.gni
@@ -45,6 +45,8 @@ blink_core_sources_inspector = [
   "inspector_dom_debugger_agent.h",
   "inspector_dom_snapshot_agent.cc",
   "inspector_dom_snapshot_agent.h",
+  "inspector_diff.cc",
+  "inspector_diff.h",
   "inspector_emulation_agent.cc",
   "inspector_emulation_agent.h",
   "inspector_frontend_client.h",
@@ -128,6 +130,7 @@ blink_core_tests_inspector = [
   "agent_registry_test.cc",
   "inspected_frames_test.cc",
   "inspector_contrast_test.cc",
+  "inspector_diff_test.cc",
   "inspector_emulation_agent_test.cc",
   "inspector_highlight_test.cc",
   "inspector_history_test.cc",
diff --git a/third_party/blink/renderer/core/inspector/inspector_diff.cc b/third_party/blink/renderer/core/inspector/inspector_diff.cc
new file mode 100644
index 0000000000000000000000000000000000000000..353918aec1beb6f02076df717a6c7390cddce434
--- /dev/null
+++ b/third_party/blink/renderer/core/inspector/inspector_diff.cc
@@ -0,0 +1,509 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// The MyersDiff was taken from v8/src/debug/liveedit-diff.cc
+
+#include "third_party/blink/renderer/core/inspector/inspector_diff.h"
+
+#include <cmath>
+#include <map>
+#include <vector>
+
+#include "base/check.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/renderer/platform/wtf/wtf_size_t.h"
+
+namespace blink {
+
+namespace {
+
+// Implements Myer's Algorithm from
+// "An O(ND) Difference Algorithm and Its Variations", particularly the
+// linear space refinement mentioned in section 4b.
+//
+// The differ is input agnostic.
+//
+// The algorithm works by finding the shortest edit string (SES) in the edit
+// graph. The SES describes how to get from a string A of length N to a string
+// B of length M via deleting from A and inserting from B.
+//
+// Example: A = "abbaa", B = "abab"
+//
+//                  A
+//
+//          a   b   b   a    a
+//        o---o---o---o---o---o
+//      a | \ |   |   | \ | \ |
+//        o---o---o---o---o---o
+//      b |   | \ | \ |   |   |
+//  B     o---o---o---o---o---o
+//      a | \ |   |   | \ | \ |
+//        o---o---o---o---o---o
+//      b |   | \ | \ |   |   |
+//        o---o---o---o---o---o
+//
+// The edit graph is constructed with the characters from string A on the x-axis
+// and the characters from string B on the y-axis. Starting from (0, 0) we can:
+//
+//     - Move right, which is equivalent to deleting from A
+//     - Move downwards, which is equivalent to inserting from B
+//     - Move diagonally if the characters from string A and B match, which
+//       means no insertion or deletion.
+//
+// Any path from (0, 0) to (N, M) describes a valid edit string, but we try to
+// find the path with the most diagonals, conversely that is the path with the
+// least insertions or deletions.
+// Note that a path with "D" insertions/deletions is called a D-path.
+class MyersDiffer {
+ private:
+  // A point in the edit graph.
+  struct Point {
+    int x, y;
+
+    // Less-than for a point in the edit graph is defined as less than in both
+    // components (i.e. at least one diagonal away).
+    bool operator<(const Point& other) const {
+      return x < other.x && y < other.y;
+    }
+  };
+
+  // Describes a rectangle in the edit graph.
+  struct EditGraphArea {
+    Point top_left, bottom_right;
+
+    int width() const { return bottom_right.x - top_left.x; }
+    int height() const { return bottom_right.y - top_left.y; }
+    int size() const { return width() + height(); }
+    int delta() const { return width() - height(); }
+  };
+
+  // A path or path-segment through the edit graph. Not all points along
+  // the path are necessarily listed since it is trivial to figure out all
+  // the concrete points along a snake.
+  struct Path {
+    Vector<Point> points;
+
+    void Add(const Point& p) { points.push_back(p); }
+    void Add(const Path& p) { points.AppendVector(p.points); }
+  };
+
+  // A snake is a path between two points that is either:
+  //
+  //     - A single right or down move followed by a (possibly empty) list of
+  //       diagonals (in the normal case).
+  //     - A (possibly empty) list of diagonals followed by a single right or
+  //       or down move (in the reverse case).
+  struct Snake {
+    Point from, to;
+  };
+
+  // A thin wrapper around Vector<int> that allows negative indexing.
+  //
+  // This class stores the x-value of the furthest reaching path
+  // for each k-diagonal. k-diagonals are numbered from -M to N and defined
+  // by y(x) = x - k.
+  //
+  // We only store the x-value instead of the full point since we can
+  // calculate y via y = x - k.
+  class FurthestReaching {
+   public:
+    explicit FurthestReaching(wtf_size_t size) : v_(size) {}
+
+    int& operator[](int index) {
+      const wtf_size_t idx = index >= 0 ? index : v_.size() + index;
+      return v_[idx];
+    }
+
+    const int& operator[](int index) const {
+      const wtf_size_t idx = index >= 0 ? index : v_.size() + index;
+      return v_[idx];
+    }
+
+   private:
+    Vector<int> v_;
+  };
+
+  class ResultWriter;
+
+  InspectorDiff::Input* input_;
+  InspectorDiff::Output* output_;
+
+  // Stores the x-value of the furthest reaching path for each k-diagonal.
+  // k-diagonals are numbered from '-height' to 'width', centered on (0,0) and
+  // are defined by y(x) = x - k.
+  FurthestReaching fr_forward_;
+
+  // Stores the x-value of the furthest reaching reverse path for each
+  // l-diagonal. l-diagonals are numbered from '-width' to 'height' and centered
+  // on 'bottom_right' of the edit graph area.
+  // k-diagonals and l-diagonals represent the same diagonals. While we refer to
+  // the diagonals as k-diagonals when calculating SES from (0,0), we refer to
+  // the diagonals as l-diagonals when calculating SES from (M,N).
+  // The corresponding k-diagonal name of an l-diagonal is: k = l + delta
+  // where delta = width -height.
+  FurthestReaching fr_reverse_;
+
+  MyersDiffer(InspectorDiff::Input* input, InspectorDiff::Output* output)
+      : input_(input),
+        output_(output),
+        fr_forward_(input->GetLength1() + input->GetLength2() + 1),
+        fr_reverse_(input->GetLength1() + input->GetLength2() + 1) {
+    // Length1 + Length2 + 1 is the upper bound for our work arrays.
+    // We allocate the work arrays once and re-use them for all invocations of
+    // `FindMiddleSnake`.
+  }
+
+  absl::optional<Path> FindEditPath() {
+    return FindEditPath(Point{0, 0},
+                        Point{input_->GetLength1(), input_->GetLength2()});
+  }
+
+  // Returns the path of the SES between `from` and `to`.
+  absl::optional<Path> FindEditPath(Point from, Point to) {
+    // Divide the area described by `from` and `to` by finding the
+    // middle snake ...
+    absl::optional<Snake> snake = FindMiddleSnake(from, to);
+
+    if (!snake) {
+      return absl::nullopt;
+    }
+
+    // ... and then conquer the two resulting sub-areas.
+    absl::optional<Path> head = FindEditPath(from, snake->from);
+    absl::optional<Path> tail = FindEditPath(snake->to, to);
+
+    // Combine `head` and `tail` or use the snake start/end points for
+    // zero-size areas.
+    Path result;
+    if (head) {
+      result.Add(*head);
+    } else {
+      result.Add(snake->from);
+    }
+
+    if (tail) {
+      result.Add(*tail);
+    } else {
+      result.Add(snake->to);
+    }
+    return result;
+  }
+
+  // Returns the snake in the middle of the area described by `from` and `to`.
+  //
+  // Incrementally calculates the D-paths (starting from 'from') and the
+  // "reverse" D-paths (starting from 'to') until we find a "normal" and a
+  // "reverse" path that overlap. That is we first calculate the normal
+  // and reverse 0-path, then the normal and reverse 1-path and so on.
+  //
+  // If a step from a (d-1)-path to a d-path overlaps with a reverse path on
+  // the same diagonal (or the other way around), then we consider that step
+  // our middle snake and return it immediately.
+  absl::optional<Snake> FindMiddleSnake(Point from, Point to) {
+    EditGraphArea area{from, to};
+    if (area.size() == 0) {
+      return absl::nullopt;
+    }
+
+    // Initialise the furthest reaching vectors with an "artificial" edge
+    // from (0, -1) -> (0, 0) and (N, -M) -> (N, M) to serve as the initial
+    // snake when d = 0.
+    fr_forward_[1] = area.top_left.x;
+    fr_reverse_[-1] = area.bottom_right.x;
+
+    for (int d = 0; d <= std::ceil(area.size() / 2.0f); ++d) {
+      if (auto snake = ShortestEditForward(area, d)) {
+        return snake;
+      }
+      if (auto snake = ShortestEditReverse(area, d)) {
+        return snake;
+      }
+    }
+
+    return absl::nullopt;
+  }
+
+  // Greedily calculates the furthest reaching `d`-paths for each k-diagonal
+  // where k is in [-d, d].  For each k-diagonal we look at the furthest
+  // reaching `d-1`-path on the `k-1` and `k+1` depending on which is further
+  // along the x-axis we either add an insertion from the `k+1`-diagonal or
+  // a deletion from the `k-1`-diagonal. Then we follow all possible diagonal
+  // moves and finally record the result as the furthest reaching path on the
+  // k-diagonal.
+  absl::optional<Snake> ShortestEditForward(const EditGraphArea& area, int d) {
+    Point from, to;
+    // We alternate between looking at odd and even k-diagonals. That is
+    // because when we extend a `d-path` by a single move we can at most move
+    // one diagonal over. That is either move from `k-1` to `k` or from `k+1` to
+    // `k`. That is if `d` is even (odd) then we require only the odd (even)
+    // k-diagonals calculated in step `d-1`.
+    for (int k = -d; k <= d; k += 2) {
+      if (k == -d || (k != d && fr_forward_[k - 1] < fr_forward_[k + 1])) {
+        // Move downwards, i.e. add an insertion, because either we are at the
+        // edge and downwards is the only way we can move, or because the
+        // `d-1`-path along the `k+1` diagonal reaches further on the x-axis
+        // than the `d-1`-path along the `k-1` diagonal.
+        from.x = to.x = fr_forward_[k + 1];
+      } else {
+        // Move right, i.e. add a deletion.
+        from.x = fr_forward_[k - 1];
+        to.x = from.x + 1;
+      }
+
+      // Calculate y via y = x - k. We need to adjust k though since the k=0
+      // diagonal is centered on `area.top_left` and not (0, 0).
+      to.y = area.top_left.y + (to.x - area.top_left.x) - k;
+      from.y = (d == 0 || from.x != to.x) ? to.y : to.y - 1;
+
+      // Extend the snake diagonally as long as we can.
+      while (to < area.bottom_right && input_->Equals(to.x, to.y)) {
+        ++to.x;
+        ++to.y;
+      }
+
+      fr_forward_[k] = to.x;
+
+      // Check whether there is a reverse path on this k-diagonal which we
+      // are overlapping with. If yes, that is our snake.
+      const bool odd = area.delta() % 2 != 0;
+      const int l = k - area.delta();
+      if (odd && l >= (-d + 1) && l <= d - 1 && to.x >= fr_reverse_[l]) {
+        return Snake{from, to};
+      }
+    }
+    return absl::nullopt;
+  }
+
+  // Greedily calculates the furthest reaching reverse `d`-paths for each
+  // l-diagonal where l is in [-d, d].
+  // Works the same as `ShortestEditForward` but we move upwards and left
+  // instead.
+  absl::optional<Snake> ShortestEditReverse(const EditGraphArea& area, int d) {
+    Point from, to;
+    // We alternate between looking at odd and even l-diagonals. That is
+    // because when we extend a `d-path` by a single move we can at most move
+    // one diagonal over. That is either move from `l-1` to `l` or from `l+1` to
+    // `l`. That is if `d` is even (odd) then we require only the odd (even)
+    // l-diagonals calculated in step `d-1`.
+    for (int l = d; l >= -d; l -= 2) {
+      if (l == d || (l != -d && fr_reverse_[l - 1] > fr_reverse_[l + 1])) {
+        // Move upwards, i.e. add an insertion, because either we are at the
+        // edge and upwards is the only way we can move, or because the
+        // `d-1`-path along the `l-1` diagonal reaches further on the x-axis
+        // than the `d-1`-path along the `l+1` diagonal.
+        from.x = to.x = fr_reverse_[l - 1];
+      } else {
+        // Move left, i.e. add a deletion.
+        from.x = fr_reverse_[l + 1];
+        to.x = from.x - 1;
+      }
+
+      // Calculate y via y = x - k. We need to adjust k though since the k=0
+      // diagonal is centered on `area.top_left` and not (0, 0).
+      const int k = l + area.delta();
+      to.y = area.top_left.y + (to.x - area.top_left.x) - k;
+      from.y = (d == 0 || from.x != to.x) ? to.y : to.y + 1;
+
+      // Extend the snake diagonally as long as we can.
+      while (area.top_left < to && input_->Equals(to.x - 1, to.y - 1)) {
+        --to.x;
+        --to.y;
+      }
+
+      fr_reverse_[l] = to.x;
+
+      // Check whether there is a path on this k-diagonal which we
+      // are overlapping with. If yes, that is our snake.
+      const bool even = area.delta() % 2 == 0;
+      if (even && k >= -d && k <= d && to.x <= fr_forward_[k]) {
+        // Invert the points so the snake goes left to right, top to bottom.
+        return Snake{to, from};
+      }
+    }
+    return absl::nullopt;
+  }
+
+  // Small helper class that converts a "shortest edit script" path into a
+  // source mapping. The result is a list of "chunks" where each "chunk"
+  // describes a range in the input string and where it can now be found
+  // in the output string.
+  //
+  // The list of chunks can be calculated in a simple pass over all the points
+  // of the edit path:
+  //
+  //     - For any diagonal we close and report the current chunk if there is
+  //       one open at the moment.
+  //     - For an insertion or deletion we open a new chunk if none is ongoing.
+  class ResultWriter {
+   public:
+    explicit ResultWriter(InspectorDiff::Output* output) : output_(output) {}
+
+    void RecordNoModification(const Point& from) {
+      output_->AddMatch(from.x, from.y);
+    }
+
+   private:
+    InspectorDiff::Output* output_;
+  };
+
+  // Takes an edit path and "fills in the blanks". That is we notify the
+  // `ResultWriter` after each single downwards, left or diagonal move.
+  void WriteResult(const Path& path) {
+    ResultWriter writer(output_);
+
+    for (wtf_size_t i = 1; i < path.points.size(); ++i) {
+      Point p1 = path.points[i - 1];
+      Point p2 = path.points[i];
+
+      p1 = WalkDiagonal(writer, p1, p2);
+      const int cmp = (p2.x - p1.x) - (p2.y - p1.y);
+      if (cmp == -1) {
+        p1.y++;
+      } else if (cmp == 1) {
+        p1.x++;
+      }
+
+      p1 = WalkDiagonal(writer, p1, p2);
+      DCHECK(p1.x == p2.x && p1.y == p2.y);
+    }
+  }
+
+  Point WalkDiagonal(ResultWriter& writer, Point p1, Point p2) {
+    while (p1.x < p2.x && p1.y < p2.y && input_->Equals(p1.x, p1.y)) {
+      writer.RecordNoModification(p1);
+      p1.x++;
+      p1.y++;
+    }
+    return p1;
+  }
+
+ public:
+  static void MyersDiff(InspectorDiff::Input* input,
+                        InspectorDiff::Output* output) {
+    MyersDiffer differ(input, output);
+    auto result = differ.FindEditPath();
+    if (!result) {
+      return;  // Empty input doesn't produce a path.
+    }
+
+    differ.WriteResult(*result);
+  }
+};
+
+class MappingInput : public InspectorDiff::Input {
+ public:
+  MappingInput(const Vector<String>& list_a,
+               const Vector<String>& list_b,
+               int start_offset,
+               int end_offset)
+      : list_a_(list_a),
+        list_b_(list_b),
+        start_offset_(start_offset),
+        end_offset_(end_offset) {}
+
+  int GetLength1() override {
+    return list_a_.size() - start_offset_ - end_offset_;
+  }
+  int GetLength2() override {
+    return list_b_.size() - start_offset_ - end_offset_;
+  }
+  bool Equals(int index1, int index2) override {
+    return list_a_.at(index1 + start_offset_) ==
+           list_b_.at(index2 + start_offset_);
+  }
+
+ private:
+  const Vector<String>& list_a_;
+  const Vector<String>& list_b_;
+  int start_offset_;
+  int end_offset_;
+};
+
+// AddChunk is called whenever a chunk is different in two lists.
+// For example, for [1, 8, 2, 3] and [4, 2, 5] It is called with these chunks:
+// * pos1 = 0, pos2 = 0; len1 = 2, len2 = 1
+// meaning that starting from index 0 there are 2 elements different in list_a
+// and starting from index 0 there is 1 element different in list_b
+// * pos1 = 3, pos2 = 2; len1 = 1, len2 = 1
+// meaning that starting from index 3, there is 1 element different in list_a
+// and starting from index 2 there are 1 element different in list_b
+// Using this property shows that the elements between two difference chunks
+// are the same.
+// For the example, initial difference chunk ends at 2nd index for list_a
+// and starts at 3rd index in the next difference chunk. Meaning that, 2nd index
+// does not belong to a difference chunk.
+class MappingOutput : public InspectorDiff::Output {
+ public:
+  MappingOutput(int start_offset,
+                InspectorIndexMap* a_to_b,
+                InspectorIndexMap* b_to_a)
+      : a_to_b_(a_to_b), b_to_a_(b_to_a), start_offset_(start_offset) {}
+
+  void AddMatch(int pos1, int pos2) override {
+    a_to_b_->Set(pos1 + start_offset_, pos2 + start_offset_);
+    b_to_a_->Set(pos2 + start_offset_, pos1 + start_offset_);
+  }
+
+ private:
+  InspectorIndexMap* a_to_b_;
+  InspectorIndexMap* b_to_a_;
+  int start_offset_;
+};
+
+}  // namespace
+
+void InspectorDiff::CalculateMatches(InspectorDiff::Input* input,
+                                     InspectorDiff::Output* result_writer) {
+  MyersDiffer::MyersDiff(input, result_writer);
+}
+
+// Finds the longest common subsequence of list_a and list_b
+// then creates a mapping from a_to_b and b_to_a that holds
+// which element in list_a exists in the longest common subsequence
+// and corresponds to which index in list_b.
+void InspectorDiff::FindLCSMapping(const Vector<String>& list_a,
+                                   const Vector<String>& list_b,
+                                   InspectorIndexMap* a_to_b,
+                                   InspectorIndexMap* b_to_a) {
+  // Cut of common prefix.
+  wtf_size_t start_offset = 0;
+  while (start_offset < list_a.size() && start_offset < list_b.size()) {
+    if (list_a.at(start_offset) != list_b.at(start_offset)) {
+      break;
+    }
+    a_to_b->Set(start_offset, start_offset);
+    b_to_a->Set(start_offset, start_offset);
+    ++start_offset;
+  }
+
+  // Cut of common suffix.
+  wtf_size_t end_offset = 0;
+  while (end_offset < list_a.size() - start_offset &&
+         end_offset < list_b.size() - start_offset) {
+    wtf_size_t index_a = list_a.size() - end_offset - 1;
+    wtf_size_t index_b = list_b.size() - end_offset - 1;
+    if (list_a.at(index_a) != list_b.at(index_b)) {
+      break;
+    }
+    a_to_b->Set(index_a, index_b);
+    b_to_a->Set(index_b, index_a);
+    ++end_offset;
+  }
+
+  wtf_size_t n = list_a.size() - start_offset - end_offset;
+  wtf_size_t m = list_b.size() - start_offset - end_offset;
+
+  // If we mapped either of arrays, we have no more work to do.
+  if (n == 0 || m == 0) {
+    return;
+  }
+
+  // Find the LCS between list_a and list_b starting from start offset and
+  // ending at end_offset
+  MappingInput input(list_a, list_b, start_offset, end_offset);
+  MappingOutput output(start_offset, a_to_b, b_to_a);
+  InspectorDiff::CalculateMatches(&input, &output);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/core/inspector/inspector_diff.h b/third_party/blink/renderer/core/inspector/inspector_diff.h
new file mode 100644
index 0000000000000000000000000000000000000000..83cb32a287b472483bfd83de6d2e7e8af5e0081b
--- /dev/null
+++ b/third_party/blink/renderer/core/inspector/inspector_diff.h
@@ -0,0 +1,57 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_CORE_INSPECTOR_INSPECTOR_DIFF_H_
+#define THIRD_PARTY_BLINK_RENDERER_CORE_INSPECTOR_INSPECTOR_DIFF_H_
+
+#include "third_party/blink/renderer/core/core_export.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+namespace blink {
+
+using InspectorIndexMap = HashMap<unsigned,
+                                  unsigned,
+                                  WTF::IntHash<unsigned>,
+                                  WTF::UnsignedWithZeroKeyHashTraits<unsigned>>;
+
+// A general-purpose comparator between 2 arrays for the inspector
+class CORE_EXPORT InspectorDiff {
+ public:
+  // Holds 2 arrays of some elements allowing to compare any pair of
+  // element from the first array and element from the second array.
+  class Input {
+   public:
+    virtual int GetLength1() = 0;
+    virtual int GetLength2() = 0;
+    virtual bool Equals(int index1, int index2) = 0;
+
+   protected:
+    virtual ~Input() = default;
+  };
+
+  // Receives compare result as a series of chunks.
+  class Output {
+   public:
+    // Called whenever a match is reported between two lists
+    virtual void AddMatch(int pos1, int pos2) = 0;
+
+   protected:
+    virtual ~Output() = default;
+  };
+
+  // Finds the LCS between two arrays and reports matching positions.
+  static void CalculateMatches(Input* input, Output* result_writer);
+
+  // Finds the mapping between 2 arrays of elements so that the
+  // mapped elements form the longest common subsequence of the arrays.
+  static void FindLCSMapping(const Vector<String>& list_a,
+                             const Vector<String>& list_b,
+                             InspectorIndexMap* a_to_b,
+                             InspectorIndexMap* b_to_a);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_CORE_INSPECTOR_INSPECTOR_DIFF_H_
diff --git a/third_party/blink/renderer/core/inspector/inspector_diff_test.cc b/third_party/blink/renderer/core/inspector/inspector_diff_test.cc
new file mode 100644
index 0000000000000000000000000000000000000000..d03afe149e3e8152a97df6ebb54f138ce5f69291
--- /dev/null
+++ b/third_party/blink/renderer/core/inspector/inspector_diff_test.cc
@@ -0,0 +1,226 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/core/inspector/inspector_diff.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+#include "third_party/googletest/src/googletest/include/gtest/gtest.h"
+
+namespace blink {
+
+class InspectorDiffTest : public testing::Test {
+ public:
+  InspectorDiffTest() = default;
+  ~InspectorDiffTest() override = default;
+};
+
+struct Match {
+  int pos1;
+  int pos2;
+
+  bool operator==(const Match& rh) const {
+    return pos1 == rh.pos1 && pos2 == rh.pos2;
+  }
+};
+
+class CompareArrayInput : public InspectorDiff::Input {
+ public:
+  CompareArrayInput(Vector<int>& list_a, Vector<int>& list_b)
+      : list_a_(list_a), list_b_(list_b) {}
+
+  int GetLength1() override { return list_a_.size(); }
+  int GetLength2() override { return list_b_.size(); }
+  bool Equals(int index1, int index2) override {
+    return list_a_.at(index1) == list_b_.at(index2);
+  }
+
+  ~CompareArrayInput() override {}
+
+ private:
+  Vector<int>& list_a_;
+  Vector<int>& list_b_;
+};
+
+class CompareArrayOutput : public InspectorDiff::Output {
+ public:
+  std::vector<Match> chunks;
+  void AddMatch(int pos1, int pos2) override {
+    chunks.emplace_back(Match({pos1, pos2}));
+  }
+};
+
+TEST_F(InspectorDiffTest, CalculateMatches) {
+  auto a = Vector<int>({1, 2, 3});
+  auto b = Vector<int>({1, 2, 3});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks,
+            std::vector({Match{0, 0}, Match{1, 1}, Match{2, 2}}));
+}
+
+TEST_F(InspectorDiffTest, CalculateMatchesAllDifferent) {
+  auto a = Vector<int>({1, 2, 3});
+  auto b = Vector<int>({4, 5, 6});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks.size(), 0ul);
+}
+
+TEST_F(InspectorDiffTest, CalculateMatchesDifferentInMiddle) {
+  auto a = Vector<int>({1, 2, 3});
+  auto b = Vector<int>({1, 999, 3});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks, std::vector({Match({0, 0}), Match({2, 2})}));
+}
+
+TEST_F(InspectorDiffTest, CalculateMatchesDifferentAtStart) {
+  auto a = Vector<int>({999, 2, 3});
+  auto b = Vector<int>({1, 2, 3});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks, std::vector({Match({1, 1}), Match({2, 2})}));
+}
+
+TEST_F(InspectorDiffTest, CalculateMatchesNoDifferentAtEnd) {
+  auto a = Vector<int>({1, 2, 999});
+  auto b = Vector<int>({1, 2, 3});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks, std::vector({Match({0, 0}), Match({1, 1})}));
+}
+
+TEST_F(InspectorDiffTest, CalculateMatchesRemoval) {
+  auto a = Vector<int>({2, 3});
+  auto b = Vector<int>({1, 2, 3});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks, std::vector({Match({0, 1}), Match({1, 2})}));
+}
+
+TEST_F(InspectorDiffTest, CalculateMatchesRemovalAndModifications) {
+  auto a = Vector<int>({2, 4});
+  auto b = Vector<int>({1, 2, 3});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks, std::vector({Match({0, 1})}));
+}
+
+TEST_F(InspectorDiffTest, CalculateMatchesFindsLCS) {
+  auto a = Vector<int>({1, 2, 5, 3, 4, 5});
+  auto b = Vector<int>({1, 2, 3, 4, 5});
+  CompareArrayInput input(a, b);
+  CompareArrayOutput output;
+
+  InspectorDiff::CalculateMatches(&input, &output);
+
+  EXPECT_EQ(output.chunks,
+            std::vector({Match({0, 0}), Match({1, 1}), Match({3, 2}),
+                         Match({4, 3}), Match({5, 4})}));
+}
+
+TEST_F(InspectorDiffTest, FindLCSMappingSameElements) {
+  auto a = Vector<String>({"a", "b"});
+  auto b = Vector<String>({"a", "b"});
+  InspectorIndexMap a_to_b;
+  InspectorIndexMap b_to_a;
+
+  InspectorDiff::FindLCSMapping(a, b, &a_to_b, &b_to_a);
+
+  EXPECT_EQ(a_to_b.size(), 2ul);
+  EXPECT_EQ(b_to_a.size(), 2ul);
+  EXPECT_EQ(a_to_b.at(0), 0ul);
+  EXPECT_EQ(a_to_b.at(1), 1ul);
+  EXPECT_EQ(b_to_a.at(0), 0ul);
+  EXPECT_EQ(b_to_a.at(1), 1ul);
+}
+
+TEST_F(InspectorDiffTest, FindLCSMappingOneElement) {
+  auto a = Vector<String>({"a", "b"});
+  auto b = Vector<String>({"b", "a"});
+  InspectorIndexMap a_to_b;
+  InspectorIndexMap b_to_a;
+
+  InspectorDiff::FindLCSMapping(a, b, &a_to_b, &b_to_a);
+
+  EXPECT_EQ(a_to_b.size(), 1ul);
+  EXPECT_EQ(b_to_a.size(), 1ul);
+  EXPECT_EQ(a_to_b.at(1), 0ul);
+  EXPECT_EQ(b_to_a.at(0), 1ul);
+}
+
+TEST_F(InspectorDiffTest, FindLCSMappingDifferentCase) {
+  auto a = Vector<String>({"blue", "blue", "green", "red", "blue"});
+  auto b = Vector<String>({"red", "blue", "green"});
+  InspectorIndexMap a_to_b;
+  InspectorIndexMap b_to_a;
+
+  InspectorDiff::FindLCSMapping(a, b, &a_to_b, &b_to_a);
+  EXPECT_EQ(b_to_a.size(), 2ul);
+  EXPECT_EQ(b_to_a.size(), 2ul);
+  EXPECT_EQ(a_to_b.at(1), 1ul);
+  EXPECT_EQ(a_to_b.at(2), 2ul);
+  EXPECT_EQ(b_to_a.at(1), 1ul);
+  EXPECT_EQ(b_to_a.at(2), 2ul);
+}
+
+TEST_F(InspectorDiffTest, FindLCSMappingNoElements) {
+  auto a = Vector<String>({"a", "b"});
+  auto b = Vector<String>({"nota", "notb"});
+  InspectorIndexMap a_to_b;
+  InspectorIndexMap b_to_a;
+
+  InspectorDiff::FindLCSMapping(a, b, &a_to_b, &b_to_a);
+
+  EXPECT_EQ(a_to_b.size(), 0ul);
+  EXPECT_EQ(b_to_a.size(), 0ul);
+}
+
+TEST_F(InspectorDiffTest, FindLCSMappingFindsLCSMapping) {
+  auto a = Vector<String>({"a", "b", "e", "c", "d", "e"});
+  auto b = Vector<String>({"b", "a", "b", "c", "d", "e", "f"});
+  InspectorIndexMap a_to_b;
+  InspectorIndexMap b_to_a;
+
+  InspectorDiff::FindLCSMapping(a, b, &a_to_b, &b_to_a);
+
+  EXPECT_EQ(a_to_b.size(), 5ul);
+  EXPECT_EQ(b_to_a.size(), 5ul);
+  EXPECT_EQ(a_to_b.at(0), 1ul);
+  EXPECT_EQ(a_to_b.at(1), 2ul);
+  EXPECT_FALSE(a_to_b.Contains(2));
+  EXPECT_EQ(a_to_b.at(3), 3ul);
+  EXPECT_EQ(a_to_b.at(4), 4ul);
+  EXPECT_EQ(a_to_b.at(5), 5ul);
+  EXPECT_FALSE(b_to_a.Contains(0));
+  EXPECT_EQ(b_to_a.at(1), 0ul);
+  EXPECT_EQ(b_to_a.at(2), 1ul);
+  EXPECT_EQ(b_to_a.at(3), 3ul);
+  EXPECT_EQ(b_to_a.at(4), 4ul);
+  EXPECT_EQ(b_to_a.at(5), 5ul);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc b/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc
index 6a8526a04b7596acc3e85f4a5200e8df65768345..690a382722026807463440926d21e4763b8548e2 100644
--- a/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc
+++ b/third_party/blink/renderer/core/inspector/inspector_style_sheet.cc
@@ -47,7 +47,6 @@
 #include "third_party/blink/renderer/core/css/parser/css_parser_observer.h"
 #include "third_party/blink/renderer/core/css/parser/css_tokenizer.h"
 #include "third_party/blink/renderer/core/css/properties/shorthand.h"
-#include "third_party/blink/renderer/core/css/style_engine.h"
 #include "third_party/blink/renderer/core/css/style_rule.h"
 #include "third_party/blink/renderer/core/css/style_sheet_contents.h"
 #include "third_party/blink/renderer/core/dom/document.h"
@@ -67,6 +66,7 @@
 #include "third_party/blink/renderer/platform/wtf/allocator/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 #include "third_party/blink/renderer/platform/wtf/text/text_position.h"
+#include "third_party/blink/renderer/platform/wtf/wtf_size_t.h"
 
 using blink::protocol::Array;
 
@@ -691,111 +691,6 @@ void CollectFlatRules(RuleList rule_list, CSSRuleVector* result) {
   }
 }
 
-typedef HashMap<unsigned,
-                unsigned,
-                WTF::IntHash<unsigned>,
-                WTF::UnsignedWithZeroKeyHashTraits<unsigned>>
-    IndexMap;
-
-void Diff(const Vector<String>& list_a,
-          const Vector<String>& list_b,
-          IndexMap* a_to_b,
-          IndexMap* b_to_a) {
-  // Cut of common prefix.
-  wtf_size_t start_offset = 0;
-  while (start_offset < list_a.size() && start_offset < list_b.size()) {
-    if (list_a.at(start_offset) != list_b.at(start_offset))
-      break;
-    a_to_b->Set(start_offset, start_offset);
-    b_to_a->Set(start_offset, start_offset);
-    ++start_offset;
-  }
-
-  // Cut of common suffix.
-  wtf_size_t end_offset = 0;
-  while (end_offset < list_a.size() - start_offset &&
-         end_offset < list_b.size() - start_offset) {
-    wtf_size_t index_a = list_a.size() - end_offset - 1;
-    wtf_size_t index_b = list_b.size() - end_offset - 1;
-    if (list_a.at(index_a) != list_b.at(index_b))
-      break;
-    a_to_b->Set(index_a, index_b);
-    b_to_a->Set(index_b, index_a);
-    ++end_offset;
-  }
-
-  wtf_size_t n = list_a.size() - start_offset - end_offset;
-  wtf_size_t m = list_b.size() - start_offset - end_offset;
-
-  // If we mapped either of arrays, we have no more work to do.
-  if (n == 0 || m == 0)
-    return;
-
-  int** diff = new int*[n];
-  int** backtrack = new int*[n];
-  for (wtf_size_t i = 0; i < n; ++i) {
-    diff[i] = new int[m];
-    backtrack[i] = new int[m];
-  }
-
-  // Compute longest common subsequence of two cssom models.
-  for (wtf_size_t i = 0; i < n; ++i) {
-    for (wtf_size_t j = 0; j < m; ++j) {
-      int max = 0;
-      int track = 0;
-
-      if (i > 0 && diff[i - 1][j] > max) {
-        max = diff[i - 1][j];
-        track = 1;
-      }
-
-      if (j > 0 && diff[i][j - 1] > max) {
-        max = diff[i][j - 1];
-        track = 2;
-      }
-
-      if (list_a.at(i + start_offset) == list_b.at(j + start_offset)) {
-        int value = i > 0 && j > 0 ? diff[i - 1][j - 1] + 1 : 1;
-        if (value > max) {
-          max = value;
-          track = 3;
-        }
-      }
-
-      diff[i][j] = max;
-      backtrack[i][j] = track;
-    }
-  }
-
-  // Backtrack and add missing mapping.
-  int i = n - 1, j = m - 1;
-  while (i >= 0 && j >= 0 && backtrack[i][j]) {
-    switch (backtrack[i][j]) {
-      case 1:
-        i -= 1;
-        break;
-      case 2:
-        j -= 1;
-        break;
-      case 3:
-        a_to_b->Set(i + start_offset, j + start_offset);
-        b_to_a->Set(j + start_offset, i + start_offset);
-        i -= 1;
-        j -= 1;
-        break;
-      default:
-        NOTREACHED();
-    }
-  }
-
-  for (wtf_size_t idx = 0; idx < n; ++idx) {
-    delete[] diff[idx];
-    delete[] backtrack[idx];
-  }
-  delete[] diff;
-  delete[] backtrack;
-}
-
 // Warning: it does not always produce valid CSS.
 // Use the rule's cssText method if you need to expose CSS externally.
 String CanonicalCSSText(CSSRule* rule) {
@@ -2148,7 +2043,7 @@ CSSRule* InspectorStyleSheet::RuleForSourceData(
   wtf_size_t index = source_data_->Find(source_data);
   if (index == kNotFound)
     return nullptr;
-  IndexMap::iterator it = source_data_to_rule_.find(index);
+  InspectorIndexMap::iterator it = source_data_to_rule_.find(index);
   if (it == source_data_to_rule_.end())
     return nullptr;
 
@@ -2171,7 +2066,7 @@ CSSRuleSourceData* InspectorStyleSheet::SourceDataForRule(CSSRule* rule) {
   wtf_size_t index = cssom_flat_rules_.Find(rule);
   if (index == kNotFound)
     return nullptr;
-  IndexMap::iterator it = rule_to_source_data_.find(index);
+  InspectorIndexMap::iterator it = rule_to_source_data_.find(index);
   if (it == rule_to_source_data_.end())
     return nullptr;
 
@@ -2239,8 +2134,8 @@ void InspectorStyleSheet::MapSourceDataToCSSOM() {
   for (wtf_size_t j = 0; j < parsed_rules.size(); ++j)
     parsed_rules_text.push_back(CanonicalCSSText(parsed_rules.at(j)));
 
-  Diff(cssom_rules_text, parsed_rules_text, &rule_to_source_data_,
-       &source_data_to_rule_);
+  InspectorDiff::FindLCSMapping(cssom_rules_text, parsed_rules_text,
+                                &rule_to_source_data_, &source_data_to_rule_);
 }
 
 const CSSRuleVector& InspectorStyleSheet::FlatRules() {
diff --git a/third_party/blink/renderer/core/inspector/inspector_style_sheet.h b/third_party/blink/renderer/core/inspector/inspector_style_sheet.h
index 1f4ea2d5544d37cb63dc57856395021c139e369a..4d667585a9c65fe91e673e103775486c68b3a3ff 100644
--- a/third_party/blink/renderer/core/inspector/inspector_style_sheet.h
+++ b/third_party/blink/renderer/core/inspector/inspector_style_sheet.h
@@ -32,6 +32,7 @@
 #include "third_party/blink/renderer/core/css/css_property_source_data.h"
 #include "third_party/blink/renderer/core/css/css_scope_rule.h"
 #include "third_party/blink/renderer/core/css/css_style_declaration.h"
+#include "third_party/blink/renderer/core/inspector/inspector_diff.h"
 #include "third_party/blink/renderer/core/inspector/protocol/css.h"
 #include "third_party/blink/renderer/platform/heap/garbage_collected.h"
 #include "third_party/blink/renderer/platform/wtf/hash_map.h"
@@ -268,13 +269,8 @@ class InspectorStyleSheet : public InspectorStyleSheetBase {
   String text_;
   CSSRuleVector cssom_flat_rules_;
   CSSRuleVector parsed_flat_rules_;
-  typedef HashMap<unsigned,
-                  unsigned,
-                  WTF::IntHash<unsigned>,
-                  WTF::UnsignedWithZeroKeyHashTraits<unsigned>>
-      IndexMap;
-  IndexMap rule_to_source_data_;
-  IndexMap source_data_to_rule_;
+  InspectorIndexMap rule_to_source_data_;
+  InspectorIndexMap source_data_to_rule_;
   String source_url_;
   // True means that CSSOM rules are to be synced with the original source text.
   bool marked_for_sync_;
diff --git a/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-external-stylesheet-expected.txt b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-external-stylesheet-expected.txt
new file mode 100644
index 0000000000000000000000000000000000000000..9a6a147ab64cc763300440566fd4e99d6d0df5c8
--- /dev/null
+++ b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-external-stylesheet-expected.txt
@@ -0,0 +1,265 @@
+The test verifies CSS.getMatchedStylesForNode when used concurrently with the CSSOM modifications for external stylesheets.
+
+Running test: testModifyRule
+--------------
+Original rule:
+*#modifyRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    height: 100%; @[5:4-5:17]
+    height: 100%; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    width: 100%; @[9:4-9:16]
+    width: 100%; @[undefined-undefined]
+}
+--------------
+Modified rule 1:
+*#modifyRule* {    regular    readonly
+    box-sizing: border-box; @[undefined-undefined]
+    color: red; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    height: 100%; @[5:4-5:17]
+    height: 100%; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    width: 100%; @[9:4-9:16]
+    width: 100%; @[undefined-undefined]
+}
+---------------
+Modified rule 3:
+*#modifyRule* {    regular    readonly
+    box-sizing: border-box; @[undefined-undefined]
+    color: red; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    height: 100%; @[5:4-5:17]
+    height: 100%; @[undefined-undefined]
+}
+*#modifyRule* {    regular    readonly
+    width: 100%; @[undefined-undefined]
+    color: blue; @[undefined-undefined]
+}
+---------------
+Modified rule 2:
+*#modifyRule* {    regular    readonly
+    box-sizing: border-box; @[undefined-undefined]
+    color: red; @[undefined-undefined]
+}
+*#modifyRule* {    regular    readonly
+    height: 100%; @[undefined-undefined]
+    color: green; @[undefined-undefined]
+}
+*#modifyRule* {    regular    readonly
+    width: 100%; @[undefined-undefined]
+    color: blue; @[undefined-undefined]
+}
+---------------
+Restored rule 2:
+*#modifyRule* {    regular    readonly
+    box-sizing: border-box; @[undefined-undefined]
+    color: red; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    height: 100%; @[5:4-5:17]
+    height: 100%; @[undefined-undefined]
+}
+*#modifyRule* {    regular    readonly
+    width: 100%; @[undefined-undefined]
+    color: blue; @[undefined-undefined]
+}
+-----------------
+Restored rule 1,3:
+*#modifyRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    height: 100%; @[5:4-5:17]
+    height: 100%; @[undefined-undefined]
+}
+*#modifyRule* {    regular
+    width: 100%; @[9:4-9:16]
+    width: 100%; @[undefined-undefined]
+}
+
+Running test: testInsertFirstRule
+Original rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+--------------
+After inserted rule:
+*#insertRule* {    regular    readonly
+    color: red; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+--------------
+Restored rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+
+Running test: testInsertMiddleRule
+Original rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+--------------
+After inserted rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular    readonly
+    color: red; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+--------------
+Restored rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+
+Running test: testInsertLastRule
+Original rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+--------------
+After inserted rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+*#insertRule* {    regular    readonly
+    color: red; @[undefined-undefined]
+}
+--------------
+Restored rule:
+*#insertRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#insertRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+
+Running test: testRemoveRule
+Original rule:
+*#removeRule* {    regular
+    box-sizing: border-box; @[1:4-1:27]
+    box-sizing: border-box; @[undefined-undefined]
+}
+*#removeRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+-------------------
+After remove rule 1:
+*#removeRule* {    regular
+    width: 100%; @[5:4-5:16]
+    width: 100%; @[undefined-undefined]
+}
+-------------------
+After remove rule 2:
+
+Running test: testMatchingPrefix
+Original rule:
+*#matchingPrefix* {    regular
+    color: red; @[1:4-1:15]
+    color: red; @[undefined-undefined]
+}
+*#matchingPrefix* {    regular
+    color: blue; @[5:4-5:16]
+    color: blue; @[undefined-undefined]
+}
+*#matchingPrefix* {    regular
+    color: green; @[9:4-9:17]
+    color: green; @[undefined-undefined]
+}
+--------------
+Modified rule 3:
+*#matchingPrefix* {    regular
+    color: red; @[1:4-1:15]
+    color: red; @[undefined-undefined]
+}
+*#matchingPrefix* {    regular
+    color: blue; @[5:4-5:16]
+    color: blue; @[undefined-undefined]
+}
+*#matchingPrefix* {    regular    readonly
+    color: purple; @[undefined-undefined]
+}
+
+Running test: testMatchingSuffix
+Original rule:
+*#matchingSuffix* {    regular
+    color: red; @[1:4-1:15]
+    color: red; @[undefined-undefined]
+}
+*#matchingSuffix* {    regular
+    color: blue; @[5:4-5:16]
+    color: blue; @[undefined-undefined]
+}
+*#matchingSuffix* {    regular
+    color: green; @[9:4-9:17]
+    color: green; @[undefined-undefined]
+}
+--------------
+Modified rule 0:
+*#matchingSuffix* {    regular    readonly
+    color: purple; @[undefined-undefined]
+}
+*#matchingSuffix* {    regular
+    color: blue; @[5:4-5:16]
+    color: blue; @[undefined-undefined]
+}
+*#matchingSuffix* {    regular
+    color: green; @[9:4-9:17]
+    color: green; @[undefined-undefined]
+}
+
diff --git a/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-external-stylesheet.js b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-external-stylesheet.js
new file mode 100644
index 0000000000000000000000000000000000000000..5998679be657420886c38b3923cecf89a963cf70
--- /dev/null
+++ b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-external-stylesheet.js
@@ -0,0 +1,119 @@
+(async function(testRunner) {
+  var {page, session, dp} = await testRunner.startHTML(`
+<link rel="stylesheet" type="text/css" href="${testRunner.url("resources/cssom-matching-rules-modify-rule.css")}">
+<link rel="stylesheet" type="text/css" href="${testRunner.url("resources/cssom-matching-rules-insert-rule.css")}">
+<link rel="stylesheet" type="text/css" href="${testRunner.url("resources/cssom-matching-rules-remove-rule.css")}">
+<link rel="stylesheet" type="text/css" href="${testRunner.url("resources/cssom-matching-rules-matching-prefix.css")}">
+<link rel="stylesheet" type="text/css" href="${testRunner.url("resources/cssom-matching-rules-matching-suffix.css")}">
+
+<article id='modifyRule'></article>
+<article id='insertRule'></article>
+<article id='removeRule'></article>
+<article id='matchingPrefix'></article>
+<article id='matchingSuffix'></article>`, 'The test verifies CSS.getMatchedStylesForNode when used concurrently with the CSSOM modifications for external stylesheets.');
+
+  var CSSHelper = await testRunner.loadScript('../resources/css-helper.js');
+  var cssHelper = new CSSHelper(testRunner, dp);
+
+  await dp.DOM.enable();
+  await dp.CSS.enable();
+
+  var documentNodeId = await cssHelper.requestDocumentNodeId();
+
+  testRunner.runTestSuite([
+    async function testModifyRule() {
+      testRunner.log('--------------');
+      testRunner.log('Original rule:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#modifyRule', true);
+
+      session.evaluate(() => document.styleSheets[0].rules[0].style.setProperty('color', 'red'));
+      testRunner.log('--------------');
+      testRunner.log('Modified rule 1:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#modifyRule', true);
+
+      session.evaluate(() => document.styleSheets[0].rules[2].style.setProperty('color', 'blue'));
+      testRunner.log('---------------');
+      testRunner.log('Modified rule 3:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#modifyRule', true);
+
+      session.evaluate(() => document.styleSheets[0].rules[1].style.setProperty('color', 'green'));
+      testRunner.log('---------------');
+      testRunner.log('Modified rule 2:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#modifyRule', true);
+
+      session.evaluate(() => document.styleSheets[0].rules[1].style.removeProperty('color'));
+      testRunner.log('---------------');
+      testRunner.log('Restored rule 2:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#modifyRule', true);
+
+      session.evaluate(() => document.styleSheets[0].rules[0].style.removeProperty('color'));
+      session.evaluate(() => document.styleSheets[0].rules[2].style.removeProperty('color'));
+      testRunner.log('-----------------');
+      testRunner.log('Restored rule 1,3:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#modifyRule', true);
+    },
+
+    async function testInsertFirstRule() {
+      await testInsertRule(0);
+    },
+
+    async function testInsertMiddleRule() {
+      await testInsertRule(1);
+    },
+
+    async function testInsertLastRule() {
+      await testInsertRule(2);
+    },
+
+    async function testRemoveRule() {
+      testRunner.log('Original rule:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#removeRule', true);
+
+      session.evaluate(() => document.styleSheets[2].removeRule(0));
+      testRunner.log('-------------------');
+      testRunner.log('After remove rule 1:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#removeRule', true);
+
+      session.evaluate(() => document.styleSheets[2].removeRule(0));
+      testRunner.log('-------------------');
+      testRunner.log('After remove rule 2:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#removeRule', true);
+    },
+
+    async function testMatchingPrefix() {
+      testRunner.log('Original rule:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#matchingPrefix', true);
+
+      session.evaluate(() => document.styleSheets[3].cssRules[2].style.setProperty('color', 'purple'));
+      testRunner.log('--------------');
+      testRunner.log('Modified rule 3:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#matchingPrefix', true);
+    },
+
+    async function testMatchingSuffix() {
+      testRunner.log('Original rule:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#matchingSuffix', true);
+
+      session.evaluate(() => document.styleSheets[4].cssRules[0].style.setProperty('color', 'purple'));
+      testRunner.log('--------------');
+      testRunner.log('Modified rule 0:');
+      await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#matchingSuffix', true);
+    }
+  ]);
+
+  async function testInsertRule(index) {
+    testRunner.log('Original rule:');
+    await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#insertRule', true);
+
+    session.evaluate(index => document.styleSheets[1].insertRule('#insertRule { color: red }', index), index);
+    testRunner.log('--------------');
+    testRunner.log('After inserted rule:');
+    await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#insertRule', true);
+
+    session.evaluate(index => document.styleSheets[1].removeRule(index), index);
+    testRunner.log('--------------');
+    testRunner.log('Restored rule:');
+    await cssHelper.loadAndDumpMatchingRules(documentNodeId, '#insertRule', true);
+  }
+})
+
diff --git a/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-expected.txt b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-internal-stylesheet-expected.txt
similarity index 98%
rename from third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-expected.txt
rename to third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-internal-stylesheet-expected.txt
index 839d2247bdbc8d2da078d1e5334b59762c3243ae..15dc3101f748049d6aa4cc88f31d67164e9efd16 100644
--- a/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-expected.txt
+++ b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-internal-stylesheet-expected.txt
@@ -1,4 +1,4 @@
-The test verifies CSS.getMatchedStylesForNode when used concurrently with the CSSOM modifications.
+The test verifies CSS.getMatchedStylesForNode when used concurrently with the CSSOM modifications for internal stylesheets.
 
 Running test: testModifyRule
 --------------
diff --git a/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules.js b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-internal-stylesheet.js
similarity index 99%
rename from third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules.js
rename to third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-internal-stylesheet.js
index 653804228ca64c272ad2253b9847c901b9b11f0e..2f26ed0b44f6908c6daf31f77accde5f36297a50 100644
--- a/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules.js
+++ b/third_party/blink/web_tests/inspector-protocol/css/cssom-matching-rules-internal-stylesheet.js
@@ -35,7 +35,7 @@
 </style>
 <article id='modifyRule'></article>
 <article id='insertRule'></article>
-<article id='removeRule'></article>`, 'The test verifies CSS.getMatchedStylesForNode when used concurrently with the CSSOM modifications.');
+<article id='removeRule'></article>`, 'The test verifies CSS.getMatchedStylesForNode when used concurrently with the CSSOM modifications for internal stylesheets.');
 
   var CSSHelper = await testRunner.loadScript('../resources/css-helper.js');
   var cssHelper = new CSSHelper(testRunner, dp);
diff --git a/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-insert-rule.css b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-insert-rule.css
new file mode 100644
index 0000000000000000000000000000000000000000..349976a87361ee506751d6b4a795ef2d89078dcd
--- /dev/null
+++ b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-insert-rule.css
@@ -0,0 +1,7 @@
+#insertRule {
+    box-sizing: border-box;
+}
+
+#insertRule {
+    width: 100%;
+}
\ No newline at end of file
diff --git a/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-matching-prefix.css b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-matching-prefix.css
new file mode 100644
index 0000000000000000000000000000000000000000..0202082b9a3779a0a4476f8aa4ad4a93f7c525ae
--- /dev/null
+++ b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-matching-prefix.css
@@ -0,0 +1,11 @@
+#matchingPrefix {
+    color: red;
+}
+
+#matchingPrefix {
+    color: blue;
+}
+
+#matchingPrefix {
+    color: green;
+}
\ No newline at end of file
diff --git a/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-matching-suffix.css b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-matching-suffix.css
new file mode 100644
index 0000000000000000000000000000000000000000..bbf0bc5996424af2de257ba02e10b415f0493d94
--- /dev/null
+++ b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-matching-suffix.css
@@ -0,0 +1,11 @@
+#matchingSuffix {
+    color: red;
+}
+
+#matchingSuffix {
+    color: blue;
+}
+
+#matchingSuffix {
+    color: green;
+}
\ No newline at end of file
diff --git a/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-modify-rule.css b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-modify-rule.css
new file mode 100644
index 0000000000000000000000000000000000000000..f98d46ecc6fb33f89f5f9e6021c28732f427ec04
--- /dev/null
+++ b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-modify-rule.css
@@ -0,0 +1,11 @@
+#modifyRule {
+    box-sizing: border-box;
+}
+
+#modifyRule {
+    height: 100%;
+}
+
+#modifyRule {
+    width: 100%;
+}
\ No newline at end of file
diff --git a/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-remove-rule.css b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-remove-rule.css
new file mode 100644
index 0000000000000000000000000000000000000000..e9ba4329fd82744757d834b9d450f76972e3b965
--- /dev/null
+++ b/third_party/blink/web_tests/inspector-protocol/css/resources/cssom-matching-rules-remove-rule.css
@@ -0,0 +1,7 @@
+#removeRule {
+    box-sizing: border-box;
+}
+
+#removeRule {
+    width: 100%;
+}
\ No newline at end of file
