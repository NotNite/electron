From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mack Straight <mack@discordapp.com>
Date: Tue, 4 May 2021 03:23:02 -0700
Subject: skid-proof video decoding memory use

videos with inline resolution changes can use arbitrary amounts of
memory to decode. upstream tried to fix this by checking for the OOM
condition when allocating, but I found it to be inadequate -- the OOM
crash just ends up happening elsewhere because we're still under severe
memory pressure.

instead, add a global memory budget for system memory allocated video
frames. I set it to 768MB because that feels like it should be enough,
but we can choose any value.

re-evaluate current state of chromium once we upgrade and drop this fix
if they put something better in.

diff --git a/media/base/BUILD.gn b/media/base/BUILD.gn
index 54e6842abd4e4041f53e75d0bcc4e0ee72d3d453..8b66eb082431ac57ea779a10ece6fc9ee46b7d9a 100644
--- a/media/base/BUILD.gn
+++ b/media/base/BUILD.gn
@@ -329,6 +329,8 @@ source_set("base") {
     "video_frame.h",
     "video_frame_layout.cc",
     "video_frame_layout.h",
+    "video_frame_memory_budget.cc",
+    "video_frame_memory_budget.h",
     "video_frame_metadata.cc",
     "video_frame_metadata.h",
     "video_frame_pool.cc",
@@ -610,6 +612,7 @@ source_set("unit_tests") {
     "video_color_space_unittest.cc",
     "video_decoder_config_unittest.cc",
     "video_frame_layout_unittest.cc",
+    "video_frame_memory_budget_unittest.cc",
     "video_frame_pool_unittest.cc",
     "video_frame_unittest.cc",
     "video_thumbnail_decoder_unittest.cc",
diff --git a/media/base/limits.h b/media/base/limits.h
index edc8fc6a39ed0fb1f48dd4bdb91f5b8a75b59d47..d56045473cbdde3ae0c2c09f02d36fad8017b5de 100644
--- a/media/base/limits.h
+++ b/media/base/limits.h
@@ -81,6 +81,11 @@ enum {
       16,  // Matches ffmpeg's MAX_AUTO_THREADS. Higher values can result in
            // immediate out of memory errors for high resolution content. See
            // https://crbug.com/893984
+
+  // Maximum number of bytes to be used to allocate system memory buffers for
+  // video frames.
+  kVideoFrameBufferMemoryBudget = 1024 * 1024 * 768,
+  kVideoFrameBufferMaxAllocationSize = 4096 * 4096 * 3,
 };
 
 }  // namespace limits
diff --git a/media/base/video_frame.cc b/media/base/video_frame.cc
index 452b1782164a129fcac15a49d2069b58377635e1..793b9d72540d85462df6179dfa93ed5b0dac419d 100644
--- a/media/base/video_frame.cc
+++ b/media/base/video_frame.cc
@@ -23,6 +23,7 @@
 #include "media/base/format_utils.h"
 #include "media/base/limits.h"
 #include "media/base/timestamp_constants.h"
+#include "media/base/video_frame_memory_budget.h"
 #include "media/base/video_util.h"
 #include "ui/gfx/buffer_format_util.h"
 #include "ui/gfx/geometry/point.h"
@@ -1355,6 +1356,10 @@ VideoFrame::~VideoFrame() {
 
   for (auto& callback : done_callbacks_)
     std::move(callback).Run();
+
+  if (budget_allocation_.has_value()) {
+    VideoFrameMemoryBudget::Current()->Release(*budget_allocation_);
+  }
 }
 
 // static
@@ -1422,8 +1427,7 @@ scoped_refptr<VideoFrame> VideoFrame::CreateFrameWithLayout(
 
   scoped_refptr<VideoFrame> frame(new VideoFrame(
       std::move(layout), storage, visible_rect, natural_size, timestamp));
-  frame->AllocateMemory(zero_initialize_memory);
-  return frame;
+  return frame->AllocateMemory(zero_initialize_memory) ? frame : nullptr;
 }
 
 // static
@@ -1438,7 +1442,7 @@ gfx::Size VideoFrame::CommonAlignment(VideoPixelFormat format) {
   return gfx::Size(max_sample_width, max_sample_height);
 }
 
-void VideoFrame::AllocateMemory(bool zero_initialize_memory) {
+bool VideoFrame::AllocateMemory(bool zero_initialize_memory) {
   DCHECK_EQ(storage_type_, STORAGE_OWNED_MEMORY);
   static_assert(0 == kYPlane, "y plane data must be index 0");
 
@@ -1446,6 +1450,13 @@ void VideoFrame::AllocateMemory(bool zero_initialize_memory) {
   const size_t total_buffer_size =
       std::accumulate(plane_size.begin(), plane_size.end(), 0u);
 
+  if (!VideoFrameMemoryBudget::Current()->Request(total_buffer_size)) {
+    LOG(ERROR) << "Video frame memory budget exhausted";
+    return false;
+  }
+
+  budget_allocation_ = total_buffer_size;
+
   uint8_t* data = reinterpret_cast<uint8_t*>(
       base::AlignedAlloc(total_buffer_size, layout_.buffer_addr_align()));
   if (zero_initialize_memory) {
@@ -1459,6 +1470,7 @@ void VideoFrame::AllocateMemory(bool zero_initialize_memory) {
     data_[plane] = data + offset;
     offset += plane_size[plane];
   }
+  return true;
 }
 
 bool VideoFrame::IsValidSharedMemoryFrame() const {
diff --git a/media/base/video_frame.h b/media/base/video_frame.h
index cf10ff045c1e8f593d5fc0143d7a6d8d28a0679f..1d48aa9539552e967ba08b93f1f657f5aefb4ac4 100644
--- a/media/base/video_frame.h
+++ b/media/base/video_frame.h
@@ -641,7 +641,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // alignment for each individual plane.
   static gfx::Size CommonAlignment(VideoPixelFormat format);
 
-  void AllocateMemory(bool zero_initialize_memory);
+  WARN_UNUSED_RESULT bool AllocateMemory(bool zero_initialize_memory);
 
   // Calculates plane size.
   // It first considers buffer size layout_ object provides. If layout's
@@ -734,6 +734,8 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // Sampler conversion information which is used in vulkan context for android.
   base::Optional<gpu::VulkanYCbCrInfo> ycbcr_info_;
 
+  base::Optional<size_t> budget_allocation_;
+
   DISALLOW_IMPLICIT_CONSTRUCTORS(VideoFrame);
 };
 
diff --git a/media/base/video_frame_memory_budget.cc b/media/base/video_frame_memory_budget.cc
new file mode 100644
index 0000000000000000000000000000000000000000..eaaa2ab6bbed02aeff33c1390d4a4621d4fc2bc7
--- /dev/null
+++ b/media/base/video_frame_memory_budget.cc
@@ -0,0 +1,72 @@
+#include "media/base/video_frame_memory_budget.h"
+
+#include "base/no_destructor.h"
+#include "base/numerics/safe_math.h"
+#include "base/threading/thread_local.h"
+
+namespace media {
+
+namespace {
+base::ThreadLocalPointer<VideoFrameMemoryBudget>&
+GetThreadLocalCurrentPointer() {
+  static base::NoDestructor<base::ThreadLocalPointer<VideoFrameMemoryBudget>>
+      tls;
+  return *tls;
+}
+}  // namespace
+
+VideoFrameMemoryBudget::VideoFrameMemoryBudget() {}
+
+VideoFrameMemoryBudget* VideoFrameMemoryBudget::Current() {
+  static base::NoDestructor<VideoFrameMemoryBudget> instance;
+  VideoFrameMemoryBudget* thread_local_budget =
+      GetThreadLocalCurrentPointer().Get();
+
+  if (thread_local_budget) {
+    return thread_local_budget;
+  }
+
+  return instance.get();
+}
+
+void VideoFrameMemoryBudget::SetThreadCurrentForTesting(
+    VideoFrameMemoryBudget* current) {
+  GetThreadLocalCurrentPointer().Set(current);
+}
+
+void VideoFrameMemoryBudget::SetMemoryLimit(size_t limit) {
+  memory_limit_ = limit;
+}
+
+void VideoFrameMemoryBudget::SetMaxAllocationSize(size_t limit) {
+  max_allocation_size_ = limit;
+}
+
+bool VideoFrameMemoryBudget::Request(size_t bytes) {
+  if (bytes > max_allocation_size_) {
+    return false;
+  }
+  while (true) {
+    size_t new_allocated;
+    size_t allocated{allocated_.load()};
+
+    if (!base::CheckAdd(allocated, bytes).AssignIfValid(&new_allocated)) {
+      return false;
+    }
+
+    if (new_allocated > memory_limit_) {
+      return false;
+    }
+
+    if (allocated_.compare_exchange_strong(allocated, new_allocated)) {
+      return true;
+    }
+  }
+}
+
+void VideoFrameMemoryBudget::Release(size_t bytes) {
+  DCHECK_GE(allocated_.load(), bytes);
+  allocated_ -= bytes;
+}
+
+}  // namespace media
\ No newline at end of file
diff --git a/media/base/video_frame_memory_budget.h b/media/base/video_frame_memory_budget.h
new file mode 100644
index 0000000000000000000000000000000000000000..ffe2c8e409c1b668ef4222fb500b3b809dddec58
--- /dev/null
+++ b/media/base/video_frame_memory_budget.h
@@ -0,0 +1,35 @@
+#ifndef MEDIA_BASE_VIDEO_FRAME_MEMORY_BUDGET_H_
+#define MEDIA_BASE_VIDEO_FRAME_MEMORY_BUDGET_H_
+
+#include <stddef.h>
+
+#include <atomic>
+
+#include "media/base/limits.h"
+
+namespace media {
+
+class VideoFrameMemoryBudget {
+ public:
+  VideoFrameMemoryBudget();
+  VideoFrameMemoryBudget(VideoFrameMemoryBudget const&) = delete;
+  VideoFrameMemoryBudget& operator=(VideoFrameMemoryBudget const&) = delete;
+  VideoFrameMemoryBudget(VideoFrameMemoryBudget&&) = delete;
+  VideoFrameMemoryBudget& operator=(VideoFrameMemoryBudget&&) = delete;
+
+  static VideoFrameMemoryBudget* Current();
+  static void SetThreadCurrentForTesting(VideoFrameMemoryBudget* current);
+  void SetMemoryLimit(size_t limit);
+  void SetMaxAllocationSize(size_t limit);
+  bool Request(size_t bytes);
+  void Release(size_t bytes);
+
+ private:
+  size_t memory_limit_{limits::kVideoFrameBufferMemoryBudget};
+  size_t max_allocation_size_{limits::kVideoFrameBufferMaxAllocationSize};
+  std::atomic<size_t> allocated_{0};
+};
+
+}  // namespace media
+
+#endif
\ No newline at end of file
diff --git a/media/base/video_frame_memory_budget_unittest.cc b/media/base/video_frame_memory_budget_unittest.cc
new file mode 100644
index 0000000000000000000000000000000000000000..3fde8b02a056ef331cd5f6721a7b71e8d268823a
--- /dev/null
+++ b/media/base/video_frame_memory_budget_unittest.cc
@@ -0,0 +1,83 @@
+#include "media/base/video_frame_memory_budget.h"
+
+#include "base/bits.h"
+#include "media/base/video_frame.h"
+#include "testing/gtest/include/gtest/gtest.h"
+
+namespace media {
+
+class VideoFrameMemoryBudgetTest : public testing::Test {
+ public:
+  VideoFrameMemoryBudgetTest() {}
+  ~VideoFrameMemoryBudgetTest() override {}
+
+ protected:
+  void SetUp() override {
+    VideoFrameMemoryBudget::SetThreadCurrentForTesting(&test_budget_);
+  }
+
+  void TearDown() override {
+    VideoFrameMemoryBudget::SetThreadCurrentForTesting(nullptr);
+  }
+
+  size_t AllocationSizeI420(size_t width, size_t height) {
+    size_t y_stride =
+        base::bits::Align(width, VideoFrame::kFrameAddressAlignment);
+    size_t y_height =
+        base::bits::Align(height, VideoFrame::kFrameAddressAlignment);
+    size_t uv_stride =
+        base::bits::Align(width / 2, VideoFrame::kFrameAddressAlignment);
+    size_t uv_height =
+        base::bits::Align(height / 2, VideoFrame::kFrameAddressAlignment);
+
+    return y_stride * y_height + 2 * uv_stride * uv_height + uv_stride +
+           VideoFrame::kFrameSizePadding;
+  }
+
+  void SetAllocationMaxI420(size_t width, size_t height) {
+    VideoFrameMemoryBudget::Current()->SetMaxAllocationSize(
+        AllocationSizeI420(width, height));
+  }
+
+  void SetMaxFramesI420(size_t width, size_t height, size_t num) {
+    VideoFrameMemoryBudget::Current()->SetMemoryLimit(
+        AllocationSizeI420(width, height) * num);
+  }
+
+  scoped_refptr<VideoFrame> CreateFrame(size_t width, size_t height) {
+    return VideoFrame::CreateZeroInitializedFrame(
+        VideoPixelFormat::PIXEL_FORMAT_I420, gfx::Size(width, height),
+        gfx::Rect(width, height), gfx::Size(width, height), base::TimeDelta());
+  }
+
+ private:
+  VideoFrameMemoryBudget test_budget_;
+};
+
+TEST_F(VideoFrameMemoryBudgetTest, TooBigFramesDontAllocate) {
+  SetAllocationMaxI420(1280, 720);
+  EXPECT_NE(CreateFrame(1280, 720), nullptr);
+  EXPECT_EQ(CreateFrame(1282, 722), nullptr);
+}
+
+TEST_F(VideoFrameMemoryBudgetTest, TooManyBigFramesDontAllocate) {
+  const size_t kWidth = 1280;
+  const size_t kHeight = 720;
+
+  SetAllocationMaxI420(kWidth, kHeight);
+  SetMaxFramesI420(kWidth, kHeight, 4);
+
+  auto frame1 = CreateFrame(kWidth, kHeight);
+  auto frame2 = CreateFrame(kWidth, kHeight);
+  auto frame3 = CreateFrame(kWidth, kHeight);
+  auto frame4 = CreateFrame(kWidth, kHeight);
+  auto frame5 = CreateFrame(kWidth, kHeight);
+
+  EXPECT_NE(frame1, nullptr);
+  EXPECT_NE(frame2, nullptr);
+  EXPECT_NE(frame3, nullptr);
+  EXPECT_NE(frame4, nullptr);
+  EXPECT_EQ(frame5, nullptr);
+}
+
+}  // namespace media
\ No newline at end of file
diff --git a/media/filters/frame_buffer_pool.cc b/media/filters/frame_buffer_pool.cc
index c6aa7d03b4aaed0cb5aaf5ab41da8ba49b1c1f61..33966f805029bd88f6d2023428a38b294df268dd 100644
--- a/media/filters/frame_buffer_pool.cc
+++ b/media/filters/frame_buffer_pool.cc
@@ -15,10 +15,14 @@
 #include "base/trace_event/memory_allocator_dump.h"
 #include "base/trace_event/memory_dump_manager.h"
 #include "base/trace_event/process_memory_dump.h"
+#include "media/base/video_frame_memory_budget.h"
 
 namespace media {
 
 struct FrameBufferPool::FrameBuffer {
+  ~FrameBuffer() {
+    VideoFrameMemoryBudget::Current()->Release(data_size);
+  }
   // Not using std::vector<uint8_t> as resize() calls take a really long time
   // for large buffers.
   std::unique_ptr<uint8_t[]> data;
@@ -66,15 +70,27 @@ uint8_t* FrameBufferPool::GetFrameBuffer(size_t min_size, void** fb_priv) {
   auto& frame_buffer = *it;
 
   // Resize the frame buffer if necessary.
-  frame_buffer->held_by_library = true;
   if (frame_buffer->data_size < min_size) {
     // Free the existing |data| first so that the memory can be reused,
     // if possible. Note that the new array is purposely not initialized.
     frame_buffer->data.reset();
+    VideoFrameMemoryBudget::Current()->Release(frame_buffer->data_size);
+    frame_buffer->data_size = 0;
+
+    if (!VideoFrameMemoryBudget::Current()->Request(min_size)) {
+      // We just dropped the previous data buffer, so if the allocation failed,
+      // erase this entry from the cache.
+      frame_buffers_.erase(it);
+      *fb_priv = nullptr;
+      return nullptr;
+    }
+
     frame_buffer->data.reset(new uint8_t[min_size]);
     frame_buffer->data_size = min_size;
   }
 
+  frame_buffer->held_by_library = true;
+
   // Provide the client with a private identifier.
   *fb_priv = frame_buffer.get();
   return frame_buffer->data.get();
diff --git a/media/filters/vpx_video_decoder.cc b/media/filters/vpx_video_decoder.cc
index 3204b5f77347ee23fb740cf172539fd8e9551017..64343b43f755e9737f689e913df3fc58ecfd9d9c 100644
--- a/media/filters/vpx_video_decoder.cc
+++ b/media/filters/vpx_video_decoder.cc
@@ -83,6 +83,10 @@ static int32_t GetVP9FrameBuffer(void* user_priv,
   FrameBufferPool* pool = static_cast<FrameBufferPool*>(user_priv);
   fb->data = pool->GetFrameBuffer(min_size, &fb->priv);
   fb->size = min_size;
+
+  if (!fb->data) {
+    return -1;
+  }
   return 0;
 }
 
diff --git a/media/test/run_all_unittests.cc b/media/test/run_all_unittests.cc
index f78864381ab0fda22ce82a9ca54b5df7ab0de32b..d795f621a8092b248d019af6cc7e6f29cb4d8e94 100644
--- a/media/test/run_all_unittests.cc
+++ b/media/test/run_all_unittests.cc
@@ -10,6 +10,7 @@
 #include "media/base/fake_localized_strings.h"
 #include "media/base/media.h"
 #include "media/base/media_switches.h"
+#include "media/base/video_frame_memory_budget.h"
 #include "mojo/core/embedder/embedder.h"
 
 #if defined(OS_ANDROID)
@@ -46,6 +47,8 @@ void TestSuiteNoAtExit::Initialize() {
   media::SetUpFakeLocalizedStrings();
 
   base::DiscardableMemoryAllocator::SetInstance(&discardable_memory_allocator_);
+  media::VideoFrameMemoryBudget::Current()->SetMemoryLimit(SIZE_MAX);
+  media::VideoFrameMemoryBudget::Current()->SetMaxAllocationSize(SIZE_MAX);
 }
 
 int main(int argc, char** argv) {
